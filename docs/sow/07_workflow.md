# 07. 開発フロー・フェーズ SOW（チェックリスト/TDD）

このファイルは、sound-stamp の開発フローを **チェックボックス付きタスクリスト** として定義したものです。  
原則として、**タスクにチェックを付けるときは、その作業内容を含む Git コミットを同時に行う** 方針とします。  
実装は可能な限り **TDD（テスト駆動開発）** で進め、次のような流れを基本とします。

- Red: 失敗するテストを書く
- Green: 最小限の実装でテストを通す
- Refactor: 実装・設計を整理し、重複を排除する

---

## Phase 0 — 環境構築

- [ ] Node.js LTS / pnpm / Firebase CLI をローカルにインストールする
- [ ] Firebase プロジェクト `sound-stamp` を作成する
- [ ] リポジトリ構成（`apps/web`, `packages/core`, `docs`, `functions`）を作成する
- [ ] Next.js プロジェクトを `apps/web` に作成する
- [ ] `packages/core` を作成し、TypeScript のビルド設定を整える
- [ ] Docker Compose および `Dockerfile.web` を作成する
- [ ] Firebase Emulator Suite を導入し、Auth / Firestore / Functions エミュレータを起動できるようにする
- [ ] `NEXT_PUBLIC_USE_FIREBASE_EMULATOR` によるエミュレータ接続切り替えを実装する
- [ ] `pnpm dev:web` で開発サーバを起動し、トップページが表示されることを確認する
- [ ] `firebase deploy --only hosting` でサンプルをデプロイし、Hosting が動作することを確認する

---

## Phase 1 — A/B ウォーターマーク生成（クライアント）

### コアロジック (`@soundstamp/core`)

- [ ] STFT / IFFT の API インターフェースを設計する
- [ ] STFT のテスト（入力サイン波から正しい周波数成分が得られること）を書く（Red）
- [ ] STFT の実装を行い、テストを通す（Green）
- [ ] IFFT のテスト（STFT → IFFT で元波形に戻ること）を書く（Red）
- [ ] IFFT の実装を行い、テストを通す（Green）
- [ ] ノイズスペクトル生成ロジック（ランダム位相＋一定振幅）のテストを書く
- [ ] A マーク（振幅変調）の API とテスト（特定ピクセルが振幅レンジに反映されること）を書く
- [ ] B マーク（位相変調）の API とテスト（位相が 0 方向に偏ること）を書く
- [ ] A/B 処理を通した上で IFFT し、音声として破綻しないことを確認する

### Web UI (`apps/web`)

- [ ] ノイズ生成ページのルーティング（例: `/generate`）を作成する
- [ ] 画像 A/B をアップロードするコンポーネントを追加する
- [ ] A/B のパラメータ設定（強度・バンド割り当て）UI を作成する
- [ ] 「ノイズ生成」ボタンで core の API を呼び出し、AudioBuffer を生成する
- [ ] ブラウザ上でプレビュー再生できるようにする
- [ ] 生成したノイズを WAV としてダウンロードできるようにする
- [ ] 最低限の E2E 的動作確認用テスト（例えば Playwright/Cypress など）を検討する（必要なら後回し可）

---

## Phase 2 — A/B 解析ツール（クライアント）

- [ ] A/B 解析用のページ（例: `/analyze`）を作成する
- [ ] 音声ファイルをアップロードし、STFT を再計算する処理を実装する
- [ ] 64 フレーム単位のブロック平均ロジックを core に実装し、テストを書く
- [ ] A 用：平均スペクトログラムから 64×64 相当のロゴを復元するロジックとテストを書く
- [ ] B 用：複素位相ベクトルの平均からロゴを復元するロジックとテストを書く
- [ ] 結果を Canvas 等で可視化し、視覚的にロゴが確認できることを手動で検証する
- [ ] 生成した音源単体を解析し、A/B のロゴが期待通りに出ることを確認する
- [ ] 実際の配信録画を解析し、どの程度ロゴが残るかを確認する

---

## Phase 3 — C 導入準備（拡張ポイント）

- [ ] `@soundstamp/core` に `applyCTokenMark`（no-op）のインターフェースを追加する
- [ ] A/B の処理パイプラインに C のフックを組み込む（呼び出すが何もしない実装）
- [ ] `03_feature_c.md` を参照しつつ、C 用のテストシナリオ（高レベル）を洗い出す
- [ ] C 無効時と有効時で A/B の動作が変わらないことを保証するテスト（将来的なための枠だけでも）を用意する

---

## Phase 4 — C ウォーターマーク実装（Functions + Firestore）

### バックエンド

- [ ] `functions` プロジェクトを作成し、Node 20 で動作するように設定する
- [ ] Firestore に `tokens` コレクションを作成する（ルールは後で締める）
- [ ] `issueToken` Cloud Function のテスト（ローカル）を書く（Red）
- [ ] `issueToken` の実装（HMAC ベースの token128 発行）を行い、テストを通す（Green）
- [ ] `verifyToken` Cloud Function のテストを書く（Red）
- [ ] `verifyToken` の実装（token128 → Firestore 照合 / HMAC 検証）を行い、テストを通す（Green）

### コア / Web 連携

- [ ] C 埋め込みロジックのインターフェースを `@soundstamp/core` に追加する
- [ ] C 埋め込みロジックのテストを書く（特定の token128 を埋め込んだ場合、解析側で同じビット列が復元できること）
- [ ] 解析ロジックに C デコード機能を追加し、テストを書く
- [ ] Web UI に「署名付きトークン有効化」チェックボックスを追加する
- [ ] トークン発行 → ノイズ生成 → 解析 → verify の一連のフローを通す結合テストを行う

---

## Phase 5 — OBS 用 UI・チューニング

- [ ] `/obs` 用のシンプルな画面を作成する（ロゴや設定を最小限に）
- [ ] 4 秒〜 60 秒程度のループノイズを生成し、常時再生する実装を行う
- [ ] CPU 負荷・メモリ使用量を Chrome DevTools などで確認する
- [ ] OBS のブラウザソースに `/obs` を指定し、実際の配信テストを行う
- [ ] 配信録画を解析し、A/B/C がどの程度残るかを評価する
- [ ] 過度に耳障りにならないようにデフォルトパラメータを調整する

---

## Phase 6 — 公開・ドキュメント整備

- [ ] `docs/sow` および README を最新状態に更新する
- [ ] 利用手順（音源生成 → OBS 設定 → 解析依頼フローなど）を Markdown でまとめる
- [ ] Zenn などへの記事草案を作成する
- [ ] GitHub リポジトリの README を整備し、OSS として公開可能かどうかを検討する
- [ ] 初期ユーザー（知り合い配信者など）に試用してもらい、フィードバックを集める

---

このチェックリストは、**進捗管理の中心**として扱う。  
タスクにチェックを入れるときは、その作業内容が反映された状態で Git コミットを行い、  
可能であればコミットメッセージに対応するタスクの概要を含める（例: `feat: add STFT core API (Phase1)`）。
